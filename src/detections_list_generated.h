// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DETECTIONSLIST_GST_OPENCV_DETECTOR_H_
#define FLATBUFFERS_GENERATED_DETECTIONSLIST_GST_OPENCV_DETECTOR_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

namespace gst_opencv_detector {

struct Rect;

struct Detection;
struct DetectionBuilder;

struct Meta;

struct DetectionList;
struct DetectionListBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t x_;
  uint32_t y_;
  uint32_t height_;
  uint32_t width_;

 public:
  Rect()
      : x_(0),
        y_(0),
        height_(0),
        width_(0) {
  }
  Rect(uint32_t _x, uint32_t _y, uint32_t _height, uint32_t _width)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        height_(::flatbuffers::EndianScalar(_height)),
        width_(::flatbuffers::EndianScalar(_width)) {
  }
  uint32_t x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  uint32_t y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  uint32_t height() const {
    return ::flatbuffers::EndianScalar(height_);
  }
  uint32_t width() const {
    return ::flatbuffers::EndianScalar(width_);
  }
};
FLATBUFFERS_STRUCT_END(Rect, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Meta FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t timestamp_;
  uint32_t image_width_;
  uint32_t image_height_;
  uint32_t crop_width_;
  uint32_t crop_height_;
  uint32_t elapsed_time_ms_;
  int32_t padding0__;

 public:
  Meta()
      : timestamp_(0),
        image_width_(0),
        image_height_(0),
        crop_width_(0),
        crop_height_(0),
        elapsed_time_ms_(0),
        padding0__(0) {
    (void)padding0__;
  }
  Meta(uint64_t _timestamp, uint32_t _image_width, uint32_t _image_height, uint32_t _crop_width, uint32_t _crop_height, uint32_t _elapsed_time_ms)
      : timestamp_(::flatbuffers::EndianScalar(_timestamp)),
        image_width_(::flatbuffers::EndianScalar(_image_width)),
        image_height_(::flatbuffers::EndianScalar(_image_height)),
        crop_width_(::flatbuffers::EndianScalar(_crop_width)),
        crop_height_(::flatbuffers::EndianScalar(_crop_height)),
        elapsed_time_ms_(::flatbuffers::EndianScalar(_elapsed_time_ms)),
        padding0__(0) {
    (void)padding0__;
  }
  uint64_t timestamp() const {
    return ::flatbuffers::EndianScalar(timestamp_);
  }
  uint32_t image_width() const {
    return ::flatbuffers::EndianScalar(image_width_);
  }
  uint32_t image_height() const {
    return ::flatbuffers::EndianScalar(image_height_);
  }
  uint32_t crop_width() const {
    return ::flatbuffers::EndianScalar(crop_width_);
  }
  uint32_t crop_height() const {
    return ::flatbuffers::EndianScalar(crop_height_);
  }
  uint32_t elapsed_time_ms() const {
    return ::flatbuffers::EndianScalar(elapsed_time_ms_);
  }
};
FLATBUFFERS_STRUCT_END(Meta, 32);

struct Detection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_CLASS_NAME = 6,
    VT_BOX = 8,
    VT_CONFIDENCE = 10
  };
  int32_t class_id() const {
    return GetField<int32_t>(VT_CLASS_ID, 0);
  }
  const ::flatbuffers::String *class_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASS_NAME);
  }
  const gst_opencv_detector::Rect *box() const {
    return GetStruct<const gst_opencv_detector::Rect *>(VT_BOX);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLASS_ID, 4) &&
           VerifyOffset(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyField<gst_opencv_detector::Rect>(verifier, VT_BOX, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct DetectionBuilder {
  typedef Detection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_class_id(int32_t class_id) {
    fbb_.AddElement<int32_t>(Detection::VT_CLASS_ID, class_id, 0);
  }
  void add_class_name(::flatbuffers::Offset<::flatbuffers::String> class_name) {
    fbb_.AddOffset(Detection::VT_CLASS_NAME, class_name);
  }
  void add_box(const gst_opencv_detector::Rect *box) {
    fbb_.AddStruct(Detection::VT_BOX, box);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(Detection::VT_CONFIDENCE, confidence, 0.0f);
  }
  explicit DetectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Detection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Detection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Detection> CreateDetection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t class_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> class_name = 0,
    const gst_opencv_detector::Rect *box = nullptr,
    float confidence = 0.0f) {
  DetectionBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_box(box);
  builder_.add_class_name(class_name);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Detection> CreateDetectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t class_id = 0,
    const char *class_name = nullptr,
    const gst_opencv_detector::Rect *box = nullptr,
    float confidence = 0.0f) {
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  return gst_opencv_detector::CreateDetection(
      _fbb,
      class_id,
      class_name__,
      box,
      confidence);
}

struct DetectionList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectionListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DETECTIONS = 6
  };
  const gst_opencv_detector::Meta *info() const {
    return GetStruct<const gst_opencv_detector::Meta *>(VT_INFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<gst_opencv_detector::Detection>> *detections() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<gst_opencv_detector::Detection>> *>(VT_DETECTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<gst_opencv_detector::Meta>(verifier, VT_INFO, 8) &&
           VerifyOffset(verifier, VT_DETECTIONS) &&
           verifier.VerifyVector(detections()) &&
           verifier.VerifyVectorOfTables(detections()) &&
           verifier.EndTable();
  }
};

struct DetectionListBuilder {
  typedef DetectionList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_info(const gst_opencv_detector::Meta *info) {
    fbb_.AddStruct(DetectionList::VT_INFO, info);
  }
  void add_detections(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<gst_opencv_detector::Detection>>> detections) {
    fbb_.AddOffset(DetectionList::VT_DETECTIONS, detections);
  }
  explicit DetectionListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DetectionList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DetectionList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DetectionList> CreateDetectionList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const gst_opencv_detector::Meta *info = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<gst_opencv_detector::Detection>>> detections = 0) {
  DetectionListBuilder builder_(_fbb);
  builder_.add_detections(detections);
  builder_.add_info(info);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DetectionList> CreateDetectionListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const gst_opencv_detector::Meta *info = nullptr,
    const std::vector<::flatbuffers::Offset<gst_opencv_detector::Detection>> *detections = nullptr) {
  auto detections__ = detections ? _fbb.CreateVector<::flatbuffers::Offset<gst_opencv_detector::Detection>>(*detections) : 0;
  return gst_opencv_detector::CreateDetectionList(
      _fbb,
      info,
      detections__);
}

}  // namespace gst_opencv_detector

#endif  // FLATBUFFERS_GENERATED_DETECTIONSLIST_GST_OPENCV_DETECTOR_H_
